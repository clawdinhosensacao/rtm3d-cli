# Synthetic benchmark notes

## Data products
Generated by `scripts/generate_synthetic_model.py`:

- Velocity model:
  - `velocity_model.bin` (float32 little-endian, `[nz][nx]`)
  - `velocity_model.bin.json` metadata
  - `x.json`, `z.json`, `vel.json` (loader-compatible arrays)
- Acquisition:
  - `shot_0001_gather.bin` (float32 little-endian, `[n_receivers][nt]`)
  - `shot_0001_gather.bin.json` metadata
  - `shot_0001.segy_like`

## SEG-Y-like format details
`shot_0001.segy_like` is a deterministic minimal interchange file:

1. 3200 bytes textual header (ASCII padded)
2. 400 bytes binary header (big-endian)
   - sample interval (`dt_us`) at bytes 17-18 (offset 16)
   - samples per trace (`nt`) at bytes 21-22 (offset 20)
   - sample format code at bytes 25-26 (offset 24), set to 5
3. Trace records (for each receiver):
   - 240 bytes trace header (big-endian)
   - `nt` samples float32 big-endian

This is intentionally not full SEG-Y compliance (no full rev1/rev2 semantics), but strict enough for binary parsing and handoff without adding dependencies.
